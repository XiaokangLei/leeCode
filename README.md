# leeCode及牛客网站部分算法刷题记录。

### 2019-12-2:countAndSay.cpp
 #38.报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
 1.     1
 2.     11
 3.     21
 4.     1211
 5.     111221
 1 被读作  "one 1"  ("一个一") , 即 11。
 11 被读作 "two 1s" ("两个一"）, 即 21。
 21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。给
 定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
 注意：整数顺序将表示为一个字符串。

### 2019-12-5:lengthOfLastWord.cpp
 #58 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。
 说明：一个单词是指由字母组成，但不包含任何空格的字符串。
 示例:
 输入: "Hello World"
 输出: 5

### 2019-12-5:plusOne.cpp
 #66给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。

示例 2:
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

### 2019-12-6:addBinary.cpp
给定两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。
示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"

### 2019-12-9:mySqrt.cpp
实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

### 2019-12-9:climbStairs.cpp
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

### 2019-12-10: singleNumber.cpp
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4

### 2019-12-10: merge.cpp
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

示例:
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]

### 2019-12-11: deleteDuplicates.cpp
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1:
输入: 1->1->2
输出: 1->2

示例 2:
输入: 1->1->2->3->3
输出: 1->2->3

### 2019-12-11: isSameTree.cpp
给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true

示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false

### LeetCode-190：颠倒给定的 32 位无符号整数的二进制位。
【思路】：按位运算（&1）得到最低位，存储在字符串（char*）中，依次将数字移位（n>>=1），得到每一位，此时字符串（char*）[0...n-1]就是已经颠倒的二进制码，调用strtol(ch,NULL,2)就可以得到二进制串转整数的结果。

### LeetCode-191:编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
【思路】：同LeetCode-190，在得到每一位二进制码（&1）时，判断二进制码是否为‘1’，计数。


### LeetCode-231:给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
【思路】：巧解方法，2的幂次方整数n的二进制表示为最高位为1，其余位为0，那么n-1的二进制表示为最高位为0，其余位为1，则n&(n-1)为0，也就是说，n&(n-1)为0时，n是2的幂次方，否则不是。

### LeetCode-461:两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 2^31.

示例:

输入: x = 1, y = 4
输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
&ensp;&ensp;&ensp;&ensp;↑&ensp;&ensp;&ensp;↑

上面的箭头指出了对应二进制位不同的位置。


【思路】：同上，依次取最低位进行比较或者异或运算，计数。

### LeetCode-693：给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。

示例 1:
输入: 5
输出: True
解释:5的二进制数是: 101

示例 2:
输入: 7
输出: False
解释:7的二进制数是: 111
示例 3:
输入: 11
输出: False
解释:11的二进制数是: 1011

示例 4:
输入: 10
输出: True
解释:10的二进制数是: 1010

【思路】：依次比较最低位(n & 1)和次低位((n & 2) >> 1)是否相同，不同则计数。